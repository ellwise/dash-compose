{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p>Dash Compose provides a tidier way of composing Plotly Dash layouts. Read about the motivation behind it here. I'm going to assume you already know how to build Dash applications, so let's get straight into an example!</p>"},{"location":"#hello-world","title":"Hello world!","text":"<p>The simple example below shows a complete Dash application, in which Dash Compose has been used to create a small tree of Dash components for the application's layout.</p> hello_world.py<pre><code>from dash import Dash, dcc, html\nfrom dash.dependencies import Input, Output\nfrom dash_compose import composition\n@composition\ndef hello_world():\nwith Div() as container:\nyield Span(\"Hello \")\nwith Span():\nyield \"world!\"\nreturn container\napp = Dash()\napp.layout = hello_world()\nif __name__ == \"__main__\":\napp.run_server(debug=True)\n</code></pre> <p>When rendered as HTML, this looks like</p> <pre><code>&lt;div&gt;\n&lt;span&gt;Hello &lt;/span&gt;\n&lt;span&gt;world!&lt;/span&gt;\n&lt;/div&gt;\n</code></pre> <p>Let's step through the layout portion of the example and see what's going on.</p>"},{"location":"#compositions","title":"Compositions","text":"<pre><code>@composition\ndef hello_world():\nwith Div() as container:\nyield Span(\"Hello \")\nwith Span():\nyield \"world!\"\nreturn container\n</code></pre> <p>Compositions are created by decorating a function, in this case <code>hello_world</code>, with <code>@composition</code>. There are no restrictions on the kinds of inputs this function takes, or on the outputs it returns. The role of the <code>@composition</code> decorator is to interpret the parent-child relationships that your function describes. Here, our function takes no inputs, and returns one output.</p>"},{"location":"#context-managers","title":"Context managers","text":"<pre><code>@composition\ndef hello_world():\nwith Div() as container:\nyield Span(\"Hello \")\nwith Span():\nyield \"world!\"\nreturn container\n</code></pre> <p>Within your function you can use Dash components as context-managers. This indicates that they will be the parent in a parent-child relationship. To specify a child in that relationship, you can use the <code>yield</code> statement after the context has been entered. Within a component's context, you can have multiple <code>yield</code> statements, or indeed any Python code you like. Here, we have yielded a <code>Span</code> within a <code>Div</code>, so the <code>Span</code> becomes a child of the <code>Div</code>.</p>"},{"location":"#nested-contexts","title":"Nested contexts","text":"<pre><code>@composition\ndef hello_world():\nwith Div() as container:\nyield Span(\"Hello \")\nwith Span():\nyield \"world!\"\nreturn container\n</code></pre> <p>You can also nest context managers. In this case, the <code>Span</code> managing the inner context will become a child of the <code>Div</code> managing the outer context.</p> <pre><code>@composition\ndef hello_world():\nwith Div() as container:\nyield Span(\"Hello \")\nwith Span():\nyield \"world!\"\nreturn container\n</code></pre> <p>When you have nested context managers, <code>yield</code> statements will create parent-child relationships based on the most recently entered context. In this case, <code>\"world!\"</code> becomes a child of <code>Span</code>, and only has an indirect relationship with the outer <code>Div</code> (it is the grand-parent of the <code>Span</code>). Note here that we have yielded something that isn't a Dash component! This is fine, you are able to yield any Python object that is a valid child of a Dash component.</p>"},{"location":"installation/","title":"Installation","text":"<p>You can install Dash Compose via GitHub.</p> <pre><code>pip install git+ssh://git@github.com/ellwise/dash-compose.git\n</code></pre>"},{"location":"motivation/","title":"Motivation","text":"<p>In a typical Dash application, child components are attached to parents as either the first argument to the parent's constructor, or via the <code>children</code> keyword argument. Either approach can lead to verbose code, with lines dedicated entirely to parentheses and many levels of indentation (especially when deep trees of components are constructed, and when code formatting tools are used).</p>"},{"location":"motivation/#a-hard-to-read-layout","title":"A hard-to-read layout","text":"<p>To illustrate a badly-formatted Dash layout, consider the following code, which has been adapted from the Plotly Dash documentation here. The layout in that example has been refactored into a function with a clear tree-structure, and then formatted using <code>black</code>. Almost half the lines of code are just parentheses or braces, and there are seven levels of indentation.</p> <pre><code>def layout():\nreturn html.Div(\n[\ndcc.Input(id=\"num-multi\", type=\"number\", value=5),\nhtml.Table(\n[\nhtml.Tr(\n[\nhtml.Td([\"x\", html.Sup(2)]),\nhtml.Td(id=\"square\"),\n]\n),\nhtml.Tr(\n[\nhtml.Td([\"x\", html.Sup(3)]),\nhtml.Td(id=\"cube\"),\n]\n),\nhtml.Tr(\n[\nhtml.Td([2, html.Sup(\"x\")]),\nhtml.Td(id=\"twos\"),\n]\n),\nhtml.Tr(\n[\nhtml.Td([3, html.Sup(\"x\")]),\nhtml.Td(id=\"threes\"),\n]\n),\nhtml.Tr(\n[\nhtml.Td([\"x\", html.Sup(\"x\")]),\nhtml.Td(id=\"x^x\"),\n]\n),\n]\n),\n]\n)\n</code></pre>"},{"location":"motivation/#an-easier-to-read-refactor","title":"An easier-to-read refactor","text":"<p>Let's refactor this code using Dash Compose. In doing so, we halve both the number of lines of code and the number of levels of indentation. This improved code density reduces visual noise, making the tree-structure of the components much clearer.</p> <pre><code>@composition\ndef layout():\nwith html.Div() as container:\nyield dcc.Input(id=\"num-multi\", type=\"number\", value=5)\nwith html.Table():\nwith html.Tr():\nyield html.Td([\"x\", html.Sup(2)])\nyield html.Td(id=\"square\")\nwith html.Tr():\nyield html.Td([\"x\", html.Sup(3)])\nyield html.Td(id=\"cube\")\nwith html.Tr():\nyield html.Td([2, html.Sup(\"x\")])\nyield html.Td(id=\"twos\")\nwith html.Tr():\nyield html.Td([3, html.Sup(\"x\")])\nyield html.Td(id=\"threes\")\nwith html.Tr():\nyield html.Td([\"x\", html.Sup(\"x\")])\nyield html.Td(id=\"x^x\")\nreturn container\n</code></pre>"}]}